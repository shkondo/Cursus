# 42-EXAM03

## LEVEL-1

### broken_gnl

### filter

## LEVEL-2

- `argv[1]`を直接変更しようとするとコンパイルエラーが出ることがあるので、新しくメモリを確保してそこにコピーしてから操作するようにする

### rip

### permutations

#### 1. 文字探索の仕組み

```
str = "abc" の場合の探索イメージ:

depth=0: □□□ （1文字目を決める）
  i=0: a を選ぶ → a□□
    depth=1: （2文字目を決める）
      i=1: b を選ぶ → ab□
        depth=2: （3文字目を決める）
          i=2: c を選ぶ → abc ✅出力
      i=2: c を選ぶ → ac□
        depth=2:
          i=1: b を選ぶ → acb ✅出力

  i=1: b を選ぶ → b□□
    （続く...）
```

重要：`i`は「どの文字を選ぶか」、`depth`は「何文字目か」を管理

#### 2. `continue`の必要性

```
// used[1] = 1 の状態（'b'が使用済み）で考える
for (int i = 0; i < len; i++)
{
    if (used[i])      // i=1の時、used[1]=1なので
        continue;     // 'b'をスキップして次へ
    // 'b'は既に使われているので選べない
}
```

#### 3. `used[]`の意味

```
used[i] = 1;  // 「str[i]の文字を使用中」とマーク
res[depth] = str[i];
perm(...);    // 再帰呼び出し（この文字を使った状態で探索）
used[i] = 0;  // バックトラック：「str[i]を未使用」に戻す
              // 次のループで別の選択肢を試すため
```

#### 4. `res[pos] = str[i]`の操作

```
// depth=0, i=2 の場合
res[0] = str[2];  // 1文字目に'c'を配置
// → "c□□" の状態を作る

// depth=1, i=0 の場合
res[1] = str[0];  // 2文字目に'a'を配置
// → "ca□" の状態を作る
```

#### メモ

- `dep`と`len`の比較で型の不一致が起きるので、`len`は int 型で統一推奨
- `used`はフラグ管理用のため、`calloc`でメモリを確保

### powerset
